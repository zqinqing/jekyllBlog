---
date: 2017-10-22 20:00:31+00:00
layout: post
title: 1.7、第一部分 第四章 表达式和运算符
categories: 表达式、运算符
tags: 表达式、运算符
---

表达式(expression)javascript中的一个短语,javascript解释器会将其计算(evaluate)出一个结果,程序中的常量是最简单的一类表达式,变量名也是一种简单的表达式,它的值就是赋值给变量的值,复杂表达式是由简单表达式组成的,比如数组访问表达式是由一个表示数组的表达式、左方括号、一个整数表达式和右方括号构成.

它们所组成的新的表达式运算结果是该数组的特定位置的元素值,同样的,函数调用表达式有一个表示函数对象的表达式和0个或多个参数表达式构成.

将简单表达式组合成复杂表达式最常用的方法就是使用运算符,(operator).运算符按照特定的运算规则鬼操作数(通常是两个)进行运算,并计算出新值,乘法运算符`*`是比较简单的例子,表达式`x*y`是对两个边路表达式x和y进行运算big得出结果,有时我们更愿意说运算符返回了一个值而不是**计算**出一个值。

本章讲解的javascrtipt运算符,同时也讲解不涉及运算符的表达式,(比如访问数组元素和函数调用)如果你熟悉C语法风格的其他编程语言,你会发现大多数javascript表达式和运算符都似曾相似。

### 4.1 原始表达式

最简单的表达式是`原始表达式`**primary expression**。原始表达式是表达式的最小单位————它们不在包含其他表达式,javascript中的原始表达式包含常量或直接量、关键字和变量。

直接量是直接在过程中出现的常数值.它们看起来像:
```js
    1.23                        // 数字直接量
    'hello'                     // 字符串直接量
    /pattern/                   // 正则表达式直接量
```

javascript数字直接量的语法在3.1节已经做了讲解,字符串直接量在3.2做了讲解。正则表达式直接量在3.2.4节做了简单的介绍,在第10章将做专门讲解。

javascript的一些保留字构成了原始表达式:

```js
    true                        // 返回一个布尔值: 真
    false                       // 返回一个布尔值: 假
    null                        // 返回一个值    : 空
    this                        // 返回"当前"对象
```

我们在3.3节和3.4节学习了true,false,null。和其他关键字不同,this并不是一个常量,它在程序不同地方返回的值也不相同,this关键字经常在面向对象编程中出现.在一个方法体内,this返回调用这个方法的对象,参照4.5节、第八章(8.2.2节)和第九章来获取关于this的详细信息、

最后,第三种原始表达式是变量:

```js
    i                           // 返回变量i的值
    sum                         // 返回sum的值
    undefined                   // undefined是全局变量,和null不同,他不是一个关键字
```
当javascript代码中出现了标识符,javascript会将其当做变量二区查找它的值,如果变量名不存在,表达式运算结果为undefined,然而,在ECMAScript 5的严格模式中,对不存在的变量进行求值会抛出一个引用错误异常

### 4.2对象和数组的初始化表达式

对象和数组初始化表达式实际上是一个新创建的对象和数组.这些 初始化表达还有时称做'对象直接量'和'数组直接量'.然而和布尔直接量不同,它们不是原始表达式,因为它们所包含的成员或者元素都是子表达式,数组初始化表达式语法非常简单,我们以此开始.

数组初始化表达式是通过一对方括号和其内由逗号隔开的列表构成的,初始化的结果是一个新创建的数组,数组的元素是逗号分隔的表达式的值:

```js
    []                              // 一个空数组:   []内留空即表示该数组没有任何元素
    [1+2,3+4]                       // 拥有两个元素的数组,第一个是3,第二个是7
```
数组初始化表达式中的元素初始化表达式也可以是初始化表达式。也就是说,这些表达式是可以嵌套的:

```js
    var matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
```

javascript对数组初始化表达式进行求值的时候,数组初始化表达式中的元素表达式也都会各自计算一次,也就是说,数组初始化表达式每次计算的值很可能是不同的.

数组直接量的列表逗号之间的元素可以省略,这是省略的空位会填充值undefined,例如:下面这个数组包含5个元素,其中三个元素是undefined：

```js
    var sparseArray = [1,,,,5];
```

数组直接量的元素列表结尾处可以留下单个逗号,这时并不会创建一个新的值为undefined的元素。

对象初始化表达式和数组初始化表达式非常类似,只是方括号被花括号代替,并且每个子表达式都包含一个属性名和一个冒号作为前缀:

```js
    var p = {x:2.3, y: -1.2};           // 一个拥有两个属性成员的对象
    var q = {};                         // 一个空对象
    q.x = 2.3;                          // q的属性成员和p一样
    q.y = -1.2;                     
```

对象直接量也可以嵌套,比如:
```js
    var recrtangle = {
        upperLeft: {
            x: 2,
            y: 2
        },
        lowerRight: {
            x: p.x + side,
            y: p.y + side
        }
    }
```

第6章和第7章会再次讨论队形和数组的初始化表达式.

### 4.3函数定义表达式
函数定义表达式定义一个javascript函数.表达式的值是这个新定义的函数,从某种意义上讲,函数定义表达式可称为'函数直接量',毕竟对象初始化表达式也称为'对象直接量'.一个典型的函数定义表达式包含关键字function,跟随其后的是一对圆括号,括号内是一个以逗号分隔的列表,列表含有0个或多个标识符**(参数名)**,然后再跟随一个由花括号包裹的javascript代码段**(函数体)**,例如:

```js
    // 这个函数返回传入参数的平方
    var square = function (x){return x * x;}

    // 调用
    square(9)
    // 输出
    81
```

函数定义表达式同样可以包含函数的名字.函数也可以通过函数语句来定义,而不是函数表达式,更多详情会在第八章中讨论.

### 4.4属性访问表达式
属性访问表达式运算得到一个对象属性一个数组元素的的值,js为属性访问定义了两种语法:

```js
    experssion.identifier
    experssion[experssion]
```
第一种写法是一个表达式后跟随一个句点和标识符,表达式指定对象,标识符则指定需要访问的属性的名称.第二种写法是使用方括号,方括号内是另一个表达式**(这种方法适用于对象和数组)**.第二个表达式指定要访问的属性和名称或者代码要访问数组元素的索引.这里有一些具体的例子:

```js
    var o = {x: 1, y: {z:3}};           // 一个示例对象
    var a = [0, 4,[4, 6]];              // 一个包含这个对象的示例数组
    o.x                                 // => 1 : 表达式o的x属性
    o.y.z                               // => 3 : 表达式o.y的z属性
    o['x']                              // => 1 : 表达式o的x属性
    a[1]                                // => 4 : 表达式a中的索引为1的元素
    a[2]['1']                           // => 6 : 表达式a[2]中索引为1的元素
    a[0].x                              // => 1 : 表达式a[0]的x属性
```

不管使用哪种形式的属性访问表达式,在`'.'`和`[`之前的表达式总是会首先计算.如果计算结果是null或者undefined,表达式会抛出一个类型错误异常,因为这两个值都不能包含任意属性,如果运算结果不是对象,(或者数组).js会将其装换为对象(参考3.6节),如果对象表达式后跟随句点和标识符,则会查找由这个标识符所指定的属性的值,并将其作为整个表达式的值返回,如果对象表达式后跟随一对方括号,则会计算方括号内的表达式的值并将它转换为字符串,不论哪种情况,如果命名的属性不存在,那么整个属性访问表达式的值就是undefined。

显然`.identifier`的写法更加简单,但需要注意的是,这种方式只适用于要访问的属性名称是合法的标识符,并且需要知道要访问的属性的名字,如果属性名称是一个保留字或者包含空格和标点符号,或是一个数字(对于数组来说),则必须使用方括号的写法.(具体示例参照3.2.1节).

对象和其属性的细节会在第6章涵盖,数组及其元素会在第七章讲述。

### 4.5调用表达式
JavaScript中的调用表达式`(invocation experssion)`是一种调用`(或者执行)`函数或方法的语法表示.它以一个函数表达式开始,这个函数表达式指代了要调用的函数,函数表达式后跟随一对圆括号,括号内是一个以逗号隔开的参数列表,参数可以有0个也可以有多个,例如:
```js
    f(0)                    // f是一个函数表达式,0是一个参数表达式
    Math.max(x,y,z);        // Math.max 是一个函数; x,y,z是参数
    a.sort();               // a.sort() 是一个函数,它没有参数
```

当对调用表达式进行求值得时候 , 首先计算函数表达式 , 然后计算参数表达式 , 得到一组参数值,如果函数表达式的值不是一个可调用的对象 , 则抛出一个类型错误异常(所有的函数都是可以调用的) , 即使宿主对象不是函数它也有可能被调用 , 这里的区别将在(8.7.7节讲述) , 然后 , 实参的是被依次赋值给形参 , 这些形参是定义函数时指定的 , 接下来考试执行函数体 , 如果函数使用return 语句给出一个返回值 , 那么这个返回值就是整个调用表达式的值 , 否则 , 调用表达式的值就是undefined , 函数调用————包括当形参表达式的个数和函数定义中实参的个数不匹配的时候运行情况————的细节将会在第8章详细讨论.

任何一个调用表达式都包含一对圆括号和左圆括号之前的表达式 , 如果这个表达式是一个属性访问表达式 , 那么这个调用称做"方法调用"(method invocation)。在方法调用中 , 执行函数体的时候 , 作为属性访问主题的对象和数组便是其调用方法内this的指向 , 这种特性使得在面向对象编程规范中 , 函数(其oo名称为"方法")可以调用其宿主对象，参照第九章以获得更相信的信息.

并不是方法调用表达式通常使用全局对象作为this关键字的值 , 然而在ECMAScript 5中 , 那些通过严格模式定义的函数在调用时将使用undefined作为this的值 , this不会指向全局对象 , 参照5.7.3节以获得更多关于严格模式的信息.

### 4.6对象创建表达式

对象表达式(object creation expression)创建一个对象并调用一个函数(这个函数称为构造函数)初始化新对象的属性 , 对象创建表达式和函数表达式非常类似 , 只是对象创建表达式之前多了一个关键了关键字**new**:

```js
    new Object();
    new Point(2 , 3);
```

如果一个对象创建表达式不需要传入任何参数给构造函数的话 , 那么这对空圆括号是可以省略掉的:

```js
    new Object
    new Date
```

当计算一个对象创建表达式的值时,和对象初始化表达式通过{}创建对象的做法一样,javascript首先创建一个新的空对象,然后javascrpt通过传入指定的参数并将这个心对象当做this的值来调用一个指定的函数,这个函数可以使用this来初始化这个新创建对象的属性,那些被当成构造函数的函数不会返回一个值,并且这个新创建并被初始化后的兑现就是对象创建表达式的值,如果一个构造函数确实返回了一个对象值,那么这个对象就作为整个对象创建表达式的值,而新创建的对象就废弃了。

构造函数的细节将在第九章讲述

### 4.7 运算符概述

javascript中的运算符用于**算符表达式**、**比较表达式**、**逻辑表达式**、**赋值表达式**等。表4-1简单列出了javascript中的运算符,作为一个方便的参照。

需要注意的是,大多数运算符都是由标点符号表示的,比如`+`和`=`.而另外一些运算符则是由关键字表示的,比如delete和instancefo.关键字运算符合标点符号所表示的运算符一样都是正规的运算符,它们的语法都非常言简意赅.

表4-1是按照运算符的优先级排序的,前面的运算符优先级要高于后面的运算符优先级,被水平分割线分隔开来的运算符具有不同的优先级,标题为A的列表运算符的结合性,L(从左至右)或R(从右至左),标题为N的列表示操作数的个数.标题为"类型"的列表表示期望的操作数类型,以及运算符的结果类型(在'——>'符号之后)。表4-1之后的段落会解释优先级,结合性和操作数类型的概念,表4-1只对运算符做简单讨论。

#### 表4-1:javascript 运

| 运算符                   | 操作                   | A | N | 类型                  |
| :----------------------- | :--------------------- |:-:|:-:| :---------------------|
| ++                       | 前/后增量              | R | 1 | lval——>num            |
| --                       | 前/后减量              | R | 1 | lval——>num            |
| -                        | 求反                   | R | 1 | num——>num             |
| +                        | 转换为数字             | R | 1 | int——>num             |
| ~                        | 按位求反               | R | 1 | int——>int             |
| !                        | 逻辑非                 | R | 1 | bool——>bool           |
| delete                   | 删除属性               | R | 1 | lval——>bool           |
| typeof                   | 检测操作数类型         | R | 1 | any——>str             |
| void                     | 返回undefined值        | R | 1 | any——>undef           |
| *、/、%                  | 乘,除,求余             | L | 2 | num,num——>num         |
| +、-                     | 加,减                  | L | 2 | num,num——>num         |
| +                        | 字符串拼接             | L | 2 | str,str——>str         |
| <<                       | 左位移                 | L | 2 | int,int——>int         |
| >>                       | 有符号右移             | L | 2 | int,int——>int         |
| >>>                      | 无符号右移             | L | 2 | int,int——>int         |
| <、<=、>、>=             | 比较数字顺序           | L | 2 | num,num——>bool        |
| <、<=、>、>=             | 比较在字母表中的顺序   | L | 2 | str,str——>bool        |
| instanceof               | 测试对象类             | L | 2 | obj,func——>bool       |
| in                       | 测试属性是否存在       | L | 2 | str,obj——>bool        |
| ==                       | 判断相等               | L | 2 | any,any——>bool        |
| !=                       | 判断不等               | L | 2 | any,any——>bool        |
| ===                      | 判断恒等               | L | 2 | any,any——>bool        |
| !==                      | 判断非恒等             | L | 2 | any,any——>bool        |
| &                        | 按位与                 | L | 2 | int,int——>int         |
| ^                        | 按位异与               | L | 2 | int,int——>int         |
| `|`                      | 按位或                 | L | 2 | int,int——>int         |
| &&                       | 逻辑与                 | L | 2 | any,any——>any         |
| `||`                     | 逻辑或                 | L | 2 | any,any——>any         |
| ?:                       | 条件运算符             | R | 3 | bool,any,any——>any    |
| =                        | 变量赋值或对象属性赋值 | R | 2 | lval,any——>any        |
| *=、/=、%=、+=、-=、&=、 | 运算且赋值             | R | 2 | lval,any——>any        |
| ^=、|=、<<=、>>=、>>>=   |                        |   |   |                       |
| ,                        | 忽略第一个操作数       | L | 2 | any,any——>any         |
|                          | 返回第二个操作数       |   |   |                       |

**! lval是left-value的简写,意思是"左值"**

#### 4.7.1操作数的个数

运算符可以根据其操作数的个数进行分类,javascript中大多数运算符(比如`*`乘法运算符)是一个二元运算符(binary operator),将两个表达式合并成一个稍复杂的表达式,换言之,它们的操作数均是两个.javascript同样支持一些一元运算符(unary operator),它们将一个表达式转换为另一个稍复杂的表达式,表达式——x中的`—`运算符就是一个一元运算符,是将操作数x求负值.最后,javascript支持一个三元运算符(ternary operator),条件判断运算符`?:`,它将三个表达式合并成一个表达式。

#### 4.7.2操作数类型和结果类型
一些运算符可以作用于任何数据类型,但仍然希望它们的操作数是指定类型的数据,并且大多数运算符返回(或计算出)一个特定类型的值。在表4-1标题为`类型`的列中列出了运算符操作数的类型(箭头前)和运算结果的类型(箭头后)。

javascript运算符通常会根据需要对操作数进行类型转换(参照3.8节).乘法运算符`*`希望操作数为数字,但表达式`'3' * '5'`却是合法的,因为javascript会将操作数转换为数字.这个表达式的值是数字15,而不是字符串`15`.之前也提到过,javascript中所有值不是真值就是假值,因此对于那些操作数是布尔类型的操作符来说,它们的操作数可以使任意类型.

有一些运算符对操作数类型有着不同程度的依赖,最明显的例子是加法运算符,"+"运算符可以对数字进行加法运算,也可以对字符串做连接,同样,比如'<'比较运算符可以根据操作数类型的不同对数字进行大笑之的比较,也可以比较字符在字母表中的次序先后,单个运算符的描述充分揭示了它们对类型有着怎样的依赖以及对操作数进行怎样的类型转换.

#### 4.7.3左值

你可能会注意到,表4-1中的赋值运算符和其他少数运算符期望它们的操作数是lval类型.左值(lvalue)是一个古来的术语,它是指"表达式只能出现在赋值运算符的左侧"。在javascript中,变量,对象属性和数组元素均是左值,ECMAScript规范允许内置函数返回一个左值,但自定义的函数则不能返回左值.

#### 4.7.4运算符的副作用

计算一个简单的表达式(比如2*3)不会对程序的运行状态造成任何影响,程序后续执行的计算也不会受到该计算的影响,而有一些表达式则具有很多副作用,前后的表达式运算会相互影响,赋值运算符是最明显的一个例子,如果给一个变量或属性赋值,那么那些使用这个变量或属性的表达式的值都会发生改变,`++`、`--`递增和递减运算符与此类似,因为它们包含隐式的赋值,delete运算符同样有副作用,删除一个属性就像(但不完全一样)给这个属性赋值undefined.

其他的javascript运算符都没有副作用,但函数调用表达式和对象创建表达式有些特别,在函数体或者构造函数内部运用了这些运算符并产生了副作用的时候,我们说函数调用表达式和对象创建表达式是有副作用的.

#### 4.7.5运算符优先级

表4-1中所示的运算符是按照优先级从高到低排序的,每个水平分割线内的一组运算符具有相同的优先级,运算符优先级控制着运算符的执行顺序,优先级高的运算符(表格的顶部)的执行总是先与优先级低,的运算符.

看一下下面这个表达式:

```js

    w = x + y * z;
```

乘法运算符 `*`比加法运算符`+`具有更高的优先级,所以乘法先执行,加法后执行,然后,由于赋值运算符`=`具有最低的优先级,因此赋值操作是在右侧的表达式计算出结果后进行的。

运算符的优先级可以通过显示使用圆括号来重写,为了让加法先执行,乘法后执行,可以这样写:

```js
    w = (x + y) * z; 
```

需要注意的是,属性访问表达式和调用表达式的优先级要比表4-1中列出的所有运算符都要高,看一下这个例子:

```js
    typeof my.functions[x](y);
``` 
尽管typeof是优先级最高的运算符之一,但typeof也是在两次属性访问和函数调用之后执行的.

实际上,如果你真的不确定你所使用的运算符的优先级,最简单的方法就是使用圆括号来强行指定运算次序,有些重要规则需要熟记:乘法和除法的优先级高于加法和减法,赋值运算的优先级非常低,通常总是最后执行的。

#### 4.7.6运算符的结合性

在表4-1中标题为A的列说明了运算符的结合性,L值从左至右结合,R指从右至左结合。
结合性指定了在多个具有同样优先级的运算符表达式中的运算顺序,从左至右是指运算的执行是按照由左到右的顺序进行,例如,减法运算符具有从左至右的结合性,因此:

```js
    
    w = x - y - z;
    
    // 和下面这段代码一样

    w = ((x - y) -z);

    // 反过来讲,下面这个表达式:

    x = ~ - y;
    w = x = y = z;
    q = a?b:c?d:e?f:g;

    // 和这段代码一模一样

    x = ~(-y); w = (x = (y = z)); q = a?b:(c?d:(e?f:g));

    // 因为一元操作符,赋值和三元条件运算符都具有从右至左的结合性
```

>!有一个需要注意很容易忽略的现象,假设存在 a = 1,那么 'b = (a++) + a;'将如何计算结果呢?按照正文所述,顺序应该是, `1)`计算 b , `2)`计算a++(假设值为c),`3)`计算a, `4)`计算c + a, `5)`将c + a的结果赋值给b.  **按照** `++`的定义,第2)步中的a++的结果依然是1,既c为1,随后a立即自增1,因此在执行第3)步时,a的值已经是2,所以b的结果为3,很多初学者会误认为a增1的操作是在表达式计算完毕后执行的。

#### 4.7.7运算顺序

运算符的优先级和结合性规定了它们在复杂的表达式中的运算顺序,但并没有规定子表达式的计算过程中的运算顺序,javascript总是严格按照从左至右的顺序来计算表达式.例如,在表达式`w = x + y * z`中,将首先计算子表达式w,然后计算x, y和z,然后,y的值和z的值相乘,再加上x的值,最后将其赋值给表达式w所指代的变量或属性,给表达式添加圆括号将会改变乘法,加法和赋值运算的关系,但从左至右的顺序是不会改变的。

只有在任何一个表达式具有副作用而影响到其他表达式的时候，其求值顺序才会和看上去有所不同，如果表达式x中的一个变量自增1,这个变量在表达式z中使用,那么实际上是先计算出了x的值在计算z的值,这一点非常重要。




