---
date: 2018-03-06 20:00:31+00:00
layout: post
title: 1.10、第一部分 第六章 javascript 对象
categories: 对象
tags: object
---

对象是javascript的基本数据类型,对象是一种`复合值`:它将很多值(原始值或者其他对象)聚合在一起,可通过名字访问这些值,对象也可看作是属性的无序集合,每个属性都是一个名/值对。属性名是字符串,因此我们可以把对象看成是从字符串到值的映射,这种基本数据结构还有很多种叫法,有些我们非常熟悉,比如`散列`(hash)、`散列表`(hashtable)、`字典`(dictionary)、`关联数组`(associativearray).然而对象不仅仅是字符串到值得映射,除了可以保持自有的属性,js对象还可以从一个称为原型的对象,继承属性,对象的方法通常是继承的属性,这种`原型式继承`(prototype inheritance)是js的核心特征.

js对象是动态的-可以新增属性也可以删除属性-但他们常用来模拟静态对象以及静态类型语言中的`结构体`(struct),有时他们也用字符串的集合(忽略名/值对中的值).

除了字符串、数字、true、false、null、和undefined之外,js的值都是对象,尽管字符串、数字和布尔值不是对象、但他们的行为和不可变对象非常类似.

3.7节已经讲到,对象是可变的,我们通过引用而非值来操作对象.如果变量x是指向一个对象的引用,那么执行代码 var y = x;变量y也是指向同一个对象的引用,而非这个对象的副本,通过变量y修改这个对象亦会对变量x造成影响.

对象最常见的用法是创建`(create)`、设置`(set)`、查找`(query)`、删除`(delete)`、检测`(test)`、和枚举`(enumerate)`、它的属性,我们会在开始的几节讲述这些基本操作,后续的几节讲述高级主题,其中相当一部分内容来自ECMAScript5.

属性包括名字和值,属性名可以使包含字符串在内的任意字符串,但对象中不能存在两个同名的属性,值可以使任意js值,或者(在ECMAScript 5)中可以是一个getter或setter函数(或两者都有).除了名字和值之外,每个属性还有一些与之相关的值,称为`属性特性`(property atterbute)。

*   ·可写(writable attribute),表明是否可以设置该属性的值。
*   ·可枚举(enumerable attribute),表明是否可以通过for/in循环返回该属性。
*   ·可配置(configurble attrbute),表明是否可以删除或修改该属性。

在ECMAScript 5之前,通过代码给对象创建的所有属性都是可写的,枚举的和可配置的,在ECMAScript 5中则可以对这些特性加以配置。

除了包含属性之外,每个对象还用有三个相关的对象特性(object attribute):

*   ·对象的原型(prototype)指向另外一个对象,本对象的属性继承自它的原型对象,
*   ·对象的类(class)是一个标识对象类型的字符串
*   ·对象的扩展标记(extensible flag)指明了(在ECMAScript 5中)是否可以向该对象添加新属性.

最后我们用下面这些术语来对三类js对象和两类属性作区分:

*   ·内置对象(native object)是由ECMAScript规范定义的对象或类,例如,数组、函数、日期和正则表达式都是内置对象
*   ·宿主对象(host object)是由ECMAScript解释器所嵌入的宿主环境,(比如web浏览器)定义的.客户端js中标识网页结构的HTMLElement对象均是宿主对象,既然宿主环境定义的方法可以当成普通的js函数对象,那么宿主对象也可以当成内置对象.
*   ·自定义对象(user-defined object)是由运行中的js代码创建的对象.
*   ·自有属性(own property)是直接在对象中定义的属性。
*   ·继承属性(inherited property)是在对象的原型对象中定义的属性。

#### 6.1创建对象

可以通过对象直接量,关键字new和(ECMAScript 5中的),object.create()函数来创建对象。

##### 6.1.1对象直接量
创建对象最简单的方式就是在js代码中使用对象直接量,对象直接量是由若干名/值对组成的的映射表,名/值对中间用冒号分隔,整个映射表用花括号括起来,属性名可以使js标识符也可以是字符串直接量,(包括空字符串)属性名可以使js标识符也可以使字符串直接量(包括空字符串)。属性的值可以使·1任意类型的js表达式,表达式的值(可以使原始值也可以是对象值)就是这个属性的值,下面有一个例子:

```js
    var empty = {};                 // 没有任何属性的对象
    var point = {x: 0, y: 0};       // 两个属性
    var point2 = {x: point.x, y: point.y+1};    // 更复杂的值
    var book = {
        "main title": "javascript", // 属性名字里有空格,必须用字符串标识
        "sub-title": "The Defintive Guide",     // 属性名里面有连字符,必须用字符串表示
        "for": "all audiences",     // for是保留字,因此必须用引号
        "author": {                 // 这个属性的值是一个对象
            firstnname: "David",    // 注意,这里的属性名都没有引号
            surname: "Flangan"
        }
    }
```

在ECMAScript 5(以及ES 3的一些实现)中,保留字可以用来做不带引号的属性名,然而对于ES3来说,使用保留字作为属性名必须使用引号引起来,在ES5中,对象直接量中的最后一个属性后的逗号将忽略,且在ES3的大部分实现中也可以忽略这个逗号,但在IE中则报错.

对象直接量是一个表达式,这个表达式的每次运算都创建并初始化一个新的对象,每次计算对象直接量的时候,也都会计算它的每个属性的值,也就是说,如果在一个重复调用的函数中的循环内使用了对象直接量,也都会计算它的每个属性的值,也就是说,如果在一个重复调用的函数中的循环体内使用了对象直接量,它将创建很多新对象,并且每次创建的对象的属性值也有可能不同.

##### 6.1.2通过new创建对象

new运算符创建并初始化一个新对象,关键字new后跟随一个函数调用,这里的函数称作构造函数(constructor),构造函数用以初始化一个新创建的对象,js语言核心中的原始类型都包含内置构造函数,例如：

```js
    var o = new Object();           // 创建一个空对象,和{}一样
    var a = new Array();            // 创建一个空数组,和[]一样
    var d = new Date();             // 创建一个表示当前时间的Date对象
    var r = new RegExp('js');       // 创建一个可以进行模式匹配的RegExp对象
```

除了这些内置构造函数,用自定义构造函数来初始化新对象也是非常常见的

##### 6.1.3原型

在讲述第三种对象创建技术之前,我们应当首先解释一下原型,每一个js对象(null除外)都和另一个对象相关联,`另一个`对象就是我们熟知的原型,每一个对象都从原型继承属性.

所有通过对象直接量创建的对象都具有同一个原型对象,并可以通过js代码`object.prototype`获得对原型对象的引用,通过关键字new和构造函数调用创建的对象的原型就是构造函数的`prototype`属性的值,因此,同使用{}创建对象一样,通过new Object()创建的对象也继承来自`Object.prototype`.同样,通过new Array()创建的对象的原型就是Array.prototype,通过new Date()创建的对象的原型就是Date.prototype.

没有原型的对象为数不多,`object.prototype`就是其中之一,它不继承任何属性,其他原型对象都是普通对象,普通对象都具有原型,所有的内置构造函数(以及大部分自定义的构造函数)都具有一个继承自Object.prototype的原型,例如,Date.prototype的属性继承自Object.prototype,因此由new Date()创建的Date对象属性同事继承自Date.prototype和Object.prototype.这一系列链接的原型对象就是所谓的`原型链`(prototype chain)。

6.2.2节讲述了属性继承的工作机制,6.8.1节会讲到如何获取对象的原型,第九章将会更详细的讨论原型和构造函数,包含如何通过编写构造函数定义对象的类,以及给构造函数的`prototype`属性赋值可以让其`实例`直接使用这个原型上的属性和方法.

##### 6.1.4 Object.create()
ES5定义了一个名为`Object.create()`的方法,它创建一个新对象,其中第一个参数就是这个对象的原型,`Object.create()`提供第二个可选参数,用以对对象的属性进行进一步描述.

Object.create()是一个静态函数,而不是提供给某个对象调用的方法,使用它的方法很简单,只需传入所需的原型对象即可:

```js
    var o1 = object.create({x: 1, y: 2});       // o1继承了属性x和y
```

如果想创建一个普通的空对象,(比如通过{}或new Object()创建的对象),需要传入Object.prototype:

```js
    var o3 = Object.create(Object.prototype);   // o3和{}和new Object()一样
```

可以通过任意原型创建新对象(换句话说,可以使用任意对象继承),这是一个强大的特性,在ES3中可以用类似例6-1中的代码来模拟原型继承:

```js
例6-1: 通过原型链继承创建一个新对象
// inherit() 返回了一个继承自原型对象p的属性的新对象
// 这里使用ES5中的Object.create()函数(如果存在的话)
// 如果不存在Object.create(),则退化使用其他方法
function inherit(p) {
    if(p == null) throw TypeError();            // p是一个对象,但不能是null
    if(Object.create) {                         // 如果Object.create()存在
        return Object.create(p);                // 直接使用它
    }
    var t = typeof p;                           // 否则进行进一步检测
    if(t !== 'Object' && t !== 'function') {
        throw typeError();
    }
    function f() {};                            // 定义一个空构造函数
    f.prototype = p;                            // 将其原型属性设置为p
    return new f();                             // 使用f()创建p的继承对象
}
```

在看完第九章关于构造函数的内容之后,例6-1中的inherit()函数会更容易理解,现在只要知道它返回的新对象继承了参数对象的属性就可以了,注意,inherit()并不能完全代替Object.create().它不能通过传入null原型来创建对象,而且不能接受可选的第二个参数,不过我们仍会在本章和第九章的实例代码中多次用到inherit();

inherit()函数的其中一个




















