---
date: 2017-10-13 20:00:31+00:00
layout: post
title: 1.4、第一部分 第三章 类型、值和变量
categories: javascript语言核心
tags: 类型、值和变量
---


### 第3章、类型、值和变量


计算机程序的运行需要对值(value) (比如数字3.14或文本 "hello world")进行操作,在编程语言中,能够表示并操作的值类型乘坐数据类型(type),编程语言最基本的特性就是能够支持多种数据类型.当程序需要将值保存起来以备将来使用时,便将其赋值给(将值 "保存"到)一个变量里(variable).变量是一个值的符号名称.可以通过名称来获得对值得引用,变量的工作机制是编程语言的另一个基本特征,本章将详细讲解js的类型,值和变量,这里的引言制作概述,你可以通过参照1.1节来帮助理解本章内容,后续的章节会更深入地讲解.

js的数据类型分为两类,原始类型(primitive type)和对象类型(object type),js中的原始类型包括数字、字符串和布尔值、本章会有单独的章节专门讲述js中的数字`Number` 3.1章 ,和字符串`string` 3.2章 ,布尔值`Boolean` 3.3章讲解.

js中有两个特殊的原始值,`null 空`和`undefined 未定义`,它们不是数字,字符串和布尔值。它们通常分别代表了各自特殊类型的唯一的成员。3.4节将会详细讲解`null`和`undefined`.

js中除了数字、字符串、布尔值、null和undefined之外的就是对象了.对象`object`是`property`的集合,每个属性都由`名/值对`值可以使原始值,比如数字、字符串、也可以是对象构成,其中有一个比较特殊的对象-全局对象`global object`。

普通的js对象是`命名值`的无序集合。js同样定义了一种特殊对象--数组`Array`,表示带编号的值得有序集合.js为数组定义了专用的语法,使数组拥有一些和普通对象不同的特有行为特性.第七章讲述数组。

js定义了另一种特殊对象`函数`.函数是具有与它相关联的可执行代码的对象.通过调用函数来运行可执行代码.并返回运算结果.和数组一样,函数的行为特征和其它对象都不一样，js为使用函数定义专用语法，对于js函数来讲最重要的是,他们都是真值，并且js可以将他们当做普通对象来对待，第八章讲诉了数组。

如果函数用来初始化`(使用new运算符)`,一个新建的对象,我们称之为构造函数`constructor`.每个构造函数定义了一类`class`对象,由构造函数初始化的对象组成的集合.类可以看做是对象类型,除了数组`Array`类和函数`Function`类之外,js语言核心定义了其它三种有用的类,日期`date`,类定义了代表日期的对象，正则`RegExp`定义了表示正则表达式`一种强大的模式匹配工具`的对象。错误`Error`类定义了那些表示js程序中运行时粗欧文和语法错误的对象,可以通过定义自己的构造函数来定义需要的类，这会在第几章讲诉。

js解释器有自己的内存管理机制，可以自动对内容进行垃圾`garbagecollection`.这以为这程序可以按需创建对象,程序员则不必担心这些对象的销毁和内存回收。当不再有任何引用指向一个对象，解释器就会知道这个对象没用了，然后自动回收它所占用的内存资源。

js是一种面向对象的语言，不严格的讲，这意味着我们不用全局定义函数去操作不同类型的值，数据类型本身可以定义方法(method)来使用值,例如，要对数组a中的元素进行排序，不必要将a传入sort()函数，而是调用a的一个方法sort();

```js
    a.sort();    // sort(a)的面向对象的版本
```

第9章，会讲诉方法的定义，从技术上讲，只有js对象才能拥有方法，然后`数字`，`字符串`和`布尔值boolean`，也可以拥有自己的方法,在js中只有`null`和`undefined`是无法拥有方法的值。

js的类型可以分为原始类型和对象类型，也可以分为可以拥有方法的类型，和不能拥有方法的类型，同样可分为吧可变`mutable`类型和不可变`immutable`类型，可变类型的值是可修改的。`对象`和`数组`属于可变类型，js程序可以更改对象属性值和数组元素的值,数字、布尔值、null和undefined属于不可变类型--比如,修改一个数值的内容本身就说不通。字符串可以看成由字符组成的数组，你可能会认为它是可变的,然而在js中,字符串是不可变的,可以访问字符串任意位置的文本,但js并未提供修改已知字符串的文本内容的方法,3.7节会详细讲解可变类型和不可变类型的不同之处。

js可以自由的进行数据类型转换，比如，如果在程序期望使用字符串的地方使用了数字，js会自动将数字转换为字符串，如果在期望使用布尔值的地方使用了非布尔值，js会进行相应的转换，类型转换规则将在3.8节讲诉，js中灵活的类型转换规则对`判断相等`、`equality`的定义亦有影响，等号运算符`==`所进行的类型转换细节将在3.8.1节详细描述。

js变量是无类型的`untyped`，变量可以被富裕任何类型的值，同样一个变量也可以重新富裕不同类型的值，使用var关键字来声明`declare`变量，js采用词法作用域`lexical scoping`。不在任何函数内声明的变量称作全局变量`globalvariable`它在js程序中热河地方都是可见的，在函数内声明的变量具有函数作用域`funcition scope`，并且只在函数内可见，变量声明和作用域将会在3.9节和3.10节详细讲解。


### 3.1数字


和其它编程语言不同，js不区分整数数值和浮点数值,js中的所有数子均用浮点数值表示。js采用`IEEE 754标准`定义的64为浮点格式表示数字，这以为这它能表示的最大值是`士1.7976931348623157*10`,最小值是`士5*10`。

按照js中的数字格式，能够表示的整数范围是从 -9 007 199 254 740 992~ 9 007 199 254 740 992 (即 -2 ~2),包括边界值，如果使用了超过此范围的整数,则无法保证地位数字的精度，然而需要注意的是，js中实际的操作(`比如数组索引,以及第4章讲到的位操作符`)则是基于32位整数。

当一个数字直接出现在js 程序中，我们称之为数字直接量 `numeric literal`js支持多种格式的珠子直接量，在接下来的小节中会有讨论，注意，在任何数字直接量前添加负号`-`可以得到他们的负值，但负号是`一元求反运算符`，并不是数字直接量语法的组成部分。


#### 3.1.1 整型直接量


在js程序中，用一个数字序列表示一个十进制整数，例如:

```js
    0
    3
    10000000
```

除了十进制的整型直接量，js同样能识别十六进制`以16为基数`值。所谓十六禁止的直接量是指以`0x`或`0X`为前缀，其后跟随十六进制数串的直接量，十六进制值是0~9之间的数字和a(A) ~ f (F)之间的字母构成，a~f的字母对应的表示数字的10~15，下面是十六进制整型直接量的例子:

```js
    Oxff // 15 * 16 + 15 = 255 (十进制)
    OxCAFE911 
```

尽管ECMAScript标准不支持不禁止直接量，但js的某些实现可以允许采用八进制`基数为8`，形式表示整数.八进制直接量以数字0开始，其后跟随一个由0~7(包括0和7)之间的数字组成的序列，例如:

```js
    0377 // 3.64 + 7 * 8 + 7 = 255 (十进制)
```

由于某些js的实现支持八进制直接量,而有些不支持,因此最好不要使用以0位前缀的整型直接量,毕竟我们也无法得知当前js的实现是否支持八进制的解析.在ECMAScript的严格模式下，八进制直接量是明令禁止的。


#### 3.1.2 浮点型直接量


浮点型直接量可以含有小数点，它们采用的是传统的实数写法，一个实数由整数部分、小数点和小数部分组成。

此外，还可以使用指数记数法表示浮点型直接量，即在实数后跟字母e或者E，后面再跟正负号。其后再加一个整型的指数，这种记数方法表示的数值，是由前面的实数乘以10的指数次幂。

```js
    // 可以使用更简洁的语法表示:
    [digits][.digits][(E|e)[(+|-)]digits]
    // 例如
    3.14
    2345.789
    .333333333333333333
    6.02e23             // 6.02 * 10<sup>23</sup>
    1.4738223E-32       // 1.4738223 * 10<sup>-32</sup>
```

#### 3.1.3javascript中的算术运算

js程序是使用语言本身提供的算术运算符来进行数字运算的。这些运算符包括加法运算符(+)、减法运算符(-)、乘法运算符(/)和求余(求整除后的余数)运算符(%).第4章将详细介绍这些以及更多的运算符.

除了基本的运算符外，js还支持更加复杂的算术运算，这些复杂运算通过作为Math对象的属性定义的函数和常亮来实现:

```js
    Math.pow(2,53)                      // => 9007199254740992  : 2 的 53次幂
    Math.round(.6)                      // => 1.0               : 四舍五入
    Math.ceil(.6)                       // => 1.0               : 向上取整
    Math.floor(.6)                      // => 0.0               : 向下求整
    Math.abs(-5)                        // => 5                 : 求绝对值
    Math.max(x,y,z)                     // => 返回最大值
    Math.min(x,y,z)                     // => 返回最小值
    Math.random()                       // => 生成一个大于等于0小于1.0的伪随机数
    Math.PI                             // => π                 : 3.141592653589793 圆周率
    Math.E                              // => e                 : e 自然对数的底数
    Math.sqrt(3)                        // => 1.7320508075688772: 3的平方根
    Math.pow(3,1/3)                     // => 1.4422495703074083: 3的立方根
    // 三角函数
    Math.sin(0)                         // => 0                 : 三角函数
    Math.cos()                          // => 0                 : 三角函数
    Math.atan()                         // => 0                 : 三角函数
    
    Math.log(10)                        // => 2.302585092994046 : 10的自然对数
    Math.log(100)/Math.LN10             // => 2                 : 以10为底100的对数
    Math.log(512)/Math.LN2              // => 9                 : 以2为底512的对数
    Math.exp(3)                         // => 20.085536923187668: e的三次幂
``` 

第三部分是专门讲解Math对象,列出了js所支持的所有数学函数

js中的算术运算在溢出`(overflow)`、下溢`(underflow)`或被零整除时不会报错，当数组运算结果超过了js所能表示的数字上限(溢出),结果为另一个特殊的无穷大(infinity)值,在js中以`Infinity`表示.无穷大值得行为特性和我们所期望的是一致的:基于它们的加、减、乘、除运算结果还是无穷大值(当然还保留它们的正负号)。

下溢(underflow)是当运算结果无线接近于零并比js能表示最小值还小的时候发生的一种情形。这种情况下，js将会返回0，当一个负数发生下溢时,js返回一个特殊的值"负零".这个值(负零)几乎和正常的零完全一样。js程序员很少用到负零。

被零整除在js并不报错: 他只是简单的返回无穷大(Infinity),或负无穷大(-Infinity).但是有一个例外。零除以零时没有意义的，这种整除运算结果也是一个非数字`(not-a-number)`值,用NaN表示，无穷大除以无穷大,给任意负数作开方运算或者算术运算符与不是数字或无法转换为数字的操作数一起使用是都将返回NaN.

js预定义了全局变量Infinity和NaN,用来表示正无穷大和非数字值.在ECMAScript3 中,这两个值是可读写的，并可修改.ECMAScript 5 修正了这个错误。将他们定义为只读的。在ECMAScript中Number对象定义的属性值也是只读的,这里有一些例子:

```js
    // Infinity
    Infinity                            // => Infinity                : 将一个可读/写的变量初始化为 infinity
    Number.POSITIVE_INFINITY            // => Infinity                : 同样的值,只读
    1/0                                 // => Infinity                : 这也是同样的值
    Number.MAX_VALUE + 1                // => 1.7976931348623157e+308 : 计算结果还是Infinity

    // -Infinity  
    Number.NEGATIVE_INFINITY            // => -Infinity               : 该表达式表示符无穷大
    -Infinity                           // => -Infinity               : 负无穷大
    -Number.MAX_VALUE - 1               // => -1.7976931348623157e+308: 负无穷大

    // NaN
    NaN                                 // => NaN                     : 将一个可读 / 写的变量初始化为NaN
    0 / 0                               // => NaN                     : 计算结果是NaN 

    // 0 && -0
    Number.MIN_VALUE/2                  // => 0                       : 发生下溢,计算结果为0
    -Number.MIN_VALUE/2                 // => -0                      : 负零
    -1 / Infinity                       // => -0                      : 负零
    -0
```

js中的非数字有一点特殊,它和任何值都不相等,包括自身.也就是说,没办法通过x == NaN来判断变量x是否是NaN。相反,应当使用x != x 来判断,当且仅当x为NaN的时候,表达式的结果才为true,函数isNaN的作用与此类似,如果参数是NaN或者是一个非数字值(比如字符串和对象),则返回true,js中有一个类似的函数`isFinite()`,在参数不是`NaN`,`Infinity`,或者`-Infinity`的时候返回true.

负零值同样有些特殊,它和正零值是相等的(甚至使用js的严格相等测试来判断),这以为这两个值几乎一模一样,除了作为除数之外:

```js
    var zero = 0;                       // => 正常的零值
    var negz = -0;                      // => 负零数
    zero === negz                       // => true: 正零值和负零值相等
    1/zero === 1/negz                   // => false: 正无穷大和负无穷大不等
```

#### 3.1.4 二进制浮点数和四舍五入错误

实数有无数个，但js通过浮点数的形式只能表示其中有限的个数(确切地说是 18 437 736 874 454 810 627),也就是说,当js中使用实数的时候,常常只是真实值的一个近似表示。

js采用了IEEE-754浮点数表示法(几乎所有现代编程语言所采用),这是一种二进制表示法,可以精确地表示分数,比如`1 / 2`,`1 / 8`, `1 / 1024`.遗憾的是,我们常用的分数(特别是金融计算方面)都是十进制分数`1 / 10`，`1 / 100`等，二进制浮点数表示法并不能精确表示类似0.1这样简单的数字.

js中的数字具有足够的精度,并可以及其近似与0.1,但事实是，数字不能精确表述的确带来了一些问题。如下:

```js
    var x = .3 - .2;                    // => 0.09999999999999998   : 30美分减去20美分
    var y = .2 - .1;                    // => 0.1                   : 20美分减去10美分
    x == y                              // => false                 : 两值不相等!
    x == .1                             // => false                 : .3 - .2 不等于 .1
    y == .1                             // => true                  : .2 - .1 等于 .1
```
由于舍入误差,0.3 和 0.2之间的近似差值实际上并不等于0.2和0.1之间的近似差值。这个问题不只在js中才会出现.理解这一点非常重要:在任何二进制浮点竖的变成语言中都会有这个问题，同样需要注意的是，上诉代码中x和y的值非常接近彼此和最终的正确值,这种计算结果可以胜任大多数的计算任务,这个问题也只有在比较两个值是否相等的时候才会出现。

js的未来版本或许会支持十进制数字类型以避免这些舍入问题,在这之前你可能愿意使用大整数进行重要的金融计算,例如,要使用整数"分"而不要使用小数"元"进行基于货币单位的运算.

#### 3.1.5 日期和时间

js语言核心包括Date()构造函数,用来创建表示日期和时间的对象,这些日期对象的方法为日期计算提供了简单的API。日期对象不想数字那样是基本数据类型.本节给出了试用日期对象的一个简单教程,在第三部分可以查阅更多细节:

```js
    var then = new Date(2011, 0, 1);                // 2011年1月1日 
    var later = new Date(2011, 0, 1, 17, 10, 30)    // 同一天,当地时间5:10:30pm
    var now = new Date();                           // 当前日期和时间
    var elapsed = now - then;                       // 日期减法: 计算时间间隔的毫秒数
    later.getFullYear();                            // 2011 get 获取年
    later.getMonth();                               // 0 get 获取从0开始计数的月份
    later.getDate();                                // 1 get 获取从1开始计算的天数
    later.getDay();                                 // 2 get 得到星期几, 0代表星期日, 1代表星期一 (javascript权威指南一书错误表示 5 代表星期一)
    later.getHours();                               // 当地时间 17 : 5pm
    later.getUTCHours();                            // 使用UTC表示小时的时间,基于时区
```

### 3.2 文本

字符串(string)是一组由16位值组成的不可变的有序序列,每个字符通常来自于Unincode字符集,js听过字符串类型来表示文本.字符串的长度(length),是所含16位值得个数.js字符串(何其数组)的索引从零开始,第一个字符的位置是`0`,第二个字符的位置是`1`,要表示一个16位值,只需要将其赋值给字符串变量即可,这个字符串长度为1。


### 字符集,内码和js字符串     

js采用utf-8编码的Unicode字符集,js字符串是由一组无符号的16位值组成的序列。最常用的Unicode字符,(这些字符属于"基于多语种平面")，都是通过16位的内码表示,并代表字符串中的单个字符,那些不能表示为16位Unicode字符则遵循UTF-8编码规则--用两个16位值组成的一个序列(亦称作"代理项对")表示,这意味着一个长度为2的js字符串(两个16位值)有可能表示一个Unicode字符

```js
    var p = "π";                    // π由16位内码表示0x03c0
    var e = "e";                    // e由17位内码表示0x1d452
    p.length                        // => 1  : p包含一个16位值
    e.length                        // => 2  : e通过UTF-16编码后包含两个16位值: "\ud835\udc52" 
```

js定义的各式字符串操作方法均作用于16位值,而非字符,且不会对代理项对做单独处理,同样,js不会对字符爱穿做标准化的加工,甚至不能保证字符串是合法的UTF-16格式.

#### 3.2.1 字符串直接量

在js程序中的字符串直接量,是由单引号或双引号括起来的字符序列,由单引号定界的字符串中可以包含双引号,由双引号定界的字符串也可以包含单引号,这里有几个字符串直接量的例子:

```js
    ""                     // 空字符串: 包含0个字符
    'testing'
    '3.14'
    'name = "myForm"'
    "Wouldn 't you prefer 0'Reilly s book?"
    "This string\nhas two lines"
    "π is the ratio of a circle's circumference to its diameter"
```

在ECMAScript 3中，字符串直接量必须写在一行,而在ECMAScript 5中,字符串直接量可以拆分成数行,每行必须以反斜线(\)结束,反斜线和行结束符都不算是字符串直接量的内容,如果希望在字符串直接量中另起一行，可以使用转义字符\n(后续会有介绍):

```js
    "two\nlines"                     // 这里定义了一个现实为两行的字符串
    "one\                            // 用三行代码定义了现实为单行的字符串,只在ECMAScript 5中可用
    long\
    line"
```

需要注意的是，当使用单引号来定界字符串时,需要格外小心英文中的缩写和所有格写法,比如can't 和 O'Reilly's.因为撇号和单引号是同一个字符，所以必须使用反斜线(\)来转义(转义符将在下一章讲解)所有的撇号。

在客户端js程序设计中,js代码会夹杂html代码的字符串，html代码也会夹杂js代码,和js一样，html也使用单引号或者双引号来定界字符串,因此当js代码和html代码混杂在一起的时候，最好再js和html代码中各自使用独立的引号风格，例如,在js表达式中使用单引号表示字符串"Thank you",而在html时间处理程序属性中则使用双引号表示字符串:

```html
    <button onclick="alert('Thank you')">Cilk Me</button>
```

#### 3.2.2 转义字符

在js字符串中,反斜线(\)有着特殊的用途,反斜线符号后加一个字符,就不再表示它们的字面含义了,比如,`\n`就是一个转义字符`(escape sequence)`,它表示的一个换行符。

另一个例子是上节中提到的转义字符`\'`,表示单引号(或撇号)。当需要在一个单引号定界的字符串内使用撇号的时候，他就显得非常有用,现在你就会明白我们为什么把它们叫做转义字符了。因为反斜线可以使我们避免使用常规方式解释单引号，当单引号不是用来标记字符串结尾时，他只是一个撇号:

```js
    'You\'re right, it can\'t be a quote'
```

表格3-1列出了js中的转义字符以及他们所代表的含义，其中有两个是通用的，通过十六进制数表示Latin-1或Unicode中的任意字码。例如\xA9表示版权符号,版权符号的Latin-1编码是十六进制数A9。同样，\u表示由4个十六进制数指定的任意Unicode字符,比如，\u03c0表示字符π

表3-1: javascript转义字符

|  转义字符  |               含义                  |
| :-------: | :--------------------------------: |
|  \o       | NUL字符(\u0000)                     |
|  \b       | 退格符(\u0008)                      |
|  \t       | 水平制表符(\u0009)                   |
|  \n       | 换行符(\u000A)                      |
|  \v       | 垂直制表符(\u000B)                  |
|  \f       | 换页符(\u000C)                      |
|  \r       | 回车符(\u002D)                      |
|  \"       | 双引号(\u0022)                      |
|  \'       | 撇号或单引号(\u0027)                |
|  \\       | 反斜线(\u005C)                      |
|  \xXX     | 由两位十六进制数XX指定的Latin-1字符    |
|  \uXXXX   | 由4位十六进制数XXXX指定的Unicode字符   |

如果`\`字符位于没有在表3-1中列出的字符前,则忽略`\`(当然,js语言将来的版本可能定义新的转移符)。比如,`\#`和`#`等价。最后,上文提到过，在ECMAScript 5中，允许在一个多行字符串直接量力的每行结束处使用反斜线。

#### 3.2.3字符串的使用

js的内置功能之一就是字符串连接，如果将加号(+)运算符用于数字,表示两数相加，但将它作用于字符串，则表示字符串连接，将第二个字符串拼接在第一个之后，例如:

```js
    msg = 'Hello, ' + 'world';             // 生成字符串'Hello, world'
    greeting = 'Welcome to my blog,'+ ' ' + name';
```

要确定一个字符串的长度-其包含的16位值得个数-可以使用字符串的length属性，比如，要得到字符串s的长度:

```js
    s.length 
```

除了legnth属性,字符串还提供许多可以调用的方法.

```js
    var s = 'hello, world';                 // 定义一个字符串
    s.charAt(0);                            // => "h"                  : 第一个字符串
    s.charAt(s.length-1);                   // => "d"                  : 最后一个字符串
    s.substring(1,4);                       // => "ell"                : 截取第二个字符到第三个字符
    s.slice(-3);                            // => "rld"                : 最后三个字符
    s.indexOf('l');                         // => 2                    : 字符l首次出现的位置
    s.lastIndexOf('l');                     // => 10                   : 字符l最后一次出现的位置
    s.indexOf('l',3);                       // => 3                    : 从第四个字符串开始，首次出现字符l的位置
    s.split(",");                           // => ["hello","world"]    : 分割成子串
    s.replace('h','H');                     // => 'Hello, world'       : 全字符串替换
    s.toUpperCase();                        // => 'HELLO,WORLD'        : 字母转为大写
    s.toLowerCase();                        // => 'hello, world'       : 字母转为小写
``` 


****
!记住，在javascript中字符串是固定不变的,类似replace()和toUpperCase()的方法都返回新字符串,原字符串本身并没有发生改变.

****

在ECMAScript 5中,字符串可以当做只读数组，除了使用charAt()方法,也可以使用方括号来访问字符串中的单个字符(16位值):

```js
    s = 'hello world';
    s[0]                                   // => 'h'
    s[s.length - 1]                        // => 'd'
```
基于Mozilla的web浏览器(比如`Firefox`)很久之前就支持这种方式的字符串索引,多数现代浏览器`IE除外`,也紧跟Mozilla的脚步，在ECMAScript 5 成型之前就支持了这一特性。


#### 3.2.4 模式匹配
javascript定义了RegExp()构造函数,用来创建表示文本匹配模式的对象,这些模式称为'正则表达式'(regular expression),javascript采用Perl中的正则表达式语法,String和RegExp对象均定义了利用正则表达式进行模式匹配和查找与替换的函数.

RegExp并不是javascript的基本类型,和Date一样,它只是一种具有实用API的特殊对象，正则表达式的语法很复杂，API也很丰富,在第十章有详细的文档介绍,RgeExp是一种强大和常用的文本处理工具,本节只是一个概述。

尽管RegExp并不是语言中的基本数据类型,但是它们依然具有直接量写法,可以直接在js程序中使用，在两条斜线之间的温恩本构成了一个正则表达式直接量,第二天斜线之后也可以跟随一个或多个字母,用来修饰匹配模式的含义,例如:

```js
    /^HTML/                                 // 匹配以HTML开始的字符串
    /[1-9][0-9]*/                           // 匹配一个非零数字,后面是任意个数字
    /\bjavascript\b/i                       // 匹配单词'javascript',忽略大小写
```

RegExp对象定义了很多有用的方法,字符串同样具有可以接受RegExp参数的方法,例如:

```js
    var text = 'testing: 1, 2, 3';          // 文本示列
    var pattern = /\d+/g;                   // 匹配所有包含一个或多个数字的实例
    pattern.test(text);                     // => true                  : 匹配成功
    text.search(pattern);                   // => 9                     : 首次匹配成功的位置  search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。
    text.match(pattern);                    // => ['1','2','3']         : 所有匹配组成的数组
    text.replace(pattern, "#");             // => "test: #, #, #"       : replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。
    text.split(/\D+/);                      // => ["", "1", "2", "3"]   : 用非数字字符截取字符串
```

### 3.3 布尔值

布尔值指代真或假,开或关、是或否。这个类型只有两个值，保留字`true`,`false`.

javascript程序中的比较语句，的结果通常都是布尔值,例如:

```js
    a == 4
```

这段代码用来检测变量a的值是否等于4. 如果等于,比较结果的布尔值就是true，如果不等，比较出来的结果则为fasle。

布尔值通常同用于javascript中的控制结构中,例如,javascript中的if/else语句，如果布尔值为true执行第一段逻辑,如果为false执行另一段逻辑,通常讲一个创建布尔值的比较直接与使用这个比较的语句结合在一起,结果如下所示:

```js
    if (a == 4)
    b = b + 1
    else 
    a = a + 1;
```

这段代码检测变量a是否等于 4如果等于,则b加1，否则a加1，我们同样在3.8节讨论到，任意javascript的值都可以转换为布尔值，下面这些值会被转换为false:

```js
    undefined
    null
    0 
    -0
    NaN
    ""                  // 空字符串
```

所有其他值，包括所有对象(数组)都会转换为true,false.和上面6个可以转换为false的值有事称做`假值`(falsy value)。javascript期望使用一个布尔值的时候,假值会被当成false,真值会被当成true。

来看一个例子，假设变量 o 是一个对象或是 null ,可以通过一条if语句来显示的检测 o 是否非 null 值。

```js
    if(o !== null)...
```

不等操作符 `!==` 将 o 与 null 比较,并得出结果为true或false。可以先忽略这里的比较语句,null是一个假值,对象是一个真值:

```js
    if (o)....
```

对于第一种情况,只有当 o 不是null时才会执行if后的代码.第二种情况的限制没那么严格:只有o不是false或任何假值(`null` and `undefined`)时他才会执行这个if。到底选择用那条语句取决于期望赋给 o 的值是什么.如果需要将null 与 o ""区分开来,则需要使用一个显式的比较.

布尔值包含toString()的方法,因此可以使用这个方法将字符串转为`true`或`false`,但它并不包含其他有用的方法，除了这个不重要的API,还有三个重要的布尔运算符.

`&&` 运算符执行了逻辑与(AND)操作,当且仅理当两个操作数都是真值时它才返回true.否则就返回false.

`||` 运算符是布尔(OR)操作，如果两个操作数其中之一为真值它就返回true,如果两个操作数都是假值则返回false。

`!` 最后一元操作符执行布尔非(NOT)操作: 如果操作数是真值则返回false: 如果是假值,则返回true、比如:

```js
    if((x == 0 && y == 0) || !(z == 0)){
        // x 和 y 都是零或者 z 是非零
    }
```

### 3.4 null 和 undefined

`null` 是javascript语言中的关键字,它表示一个特殊值,常用描述`空值`。对null执行typeof预算,结果返回字符串`object`,也就是说,可以将null认为是一个特殊的对象值,含义是`非对象`。但实际上，通常认为null是它自有类型的唯一一个成员,它可以表示数字,字符串，和对象是`无值`的.大多数编程语言和javascript一样含有null,你可能对null或nil很眼熟.

javascript还有第二个值来表示值得空缺,用未定义的值表示更深层次的`空值`.它是变量的一种取值,表明变量没有初始化,如果要查询独享属性或数组元素的值时返回undefined则说明这个属性或元素不存在.如果函数没有返回任何值,则返回undefiend.引用没有提供实参的函数形参的值也只会得到undefined.undefined是预定义的全局权利(它和null不一样,它不是关键字),他的值就是`未定义`.在ECMAScript 5中做了修正，undefined在该版本中是只读的，如果使用typeof 运算符得到undefined的类型,则返回`undefined`，表明这个值时这个类型的唯一成员.

尽管null和undefined是不同的,但它们都表示`值的空缺`,两者往往可以来往。判断相等运算符`==`认为两者是相等的(要使用严格相等运算符 `===` 来区分它们)。在希望值时布尔类型的地方它们的值都是假值，和false类似，null和undefined都不会包含任何属性和方法，实际上，使用`.`和`[]`来存取这两个值得成员或方法都会产生一个类型错误.

你或许认为undefined是表示系统级的、出乎意料的或类似的值得空缺，而null是表示程序级的，正常的或在意料之中的值得空缺。如果你想将他们赋值给变量或者属性.或将他们作为参数传入函数.最佳选择是使用null。

### 3.5 全局对象

前几节讨论了javascript的原始类型和原始值，对象类型--`对象`、数组和函数--在本书中均会有独立章节来讲诉,但有一类非常重要的对象，我们不得不现在就把他们讲清楚，全局对象，`全局对象(global object)`,在javascript中有着重要的用途，全局对象的属性是全局定义的符号，javascript程序可以直接使用，当javascript解释器启动时(或者任何web浏览器加载新页面的时候)，它将创建一个新的全局对象，并给它一组定义的初始属性:

* · 全局属性,比如 undefined、Infinity和NaN
* · 全局函数,比如isNaN()、parseInt()和eval();
* · 构造函数,比如Date()、RegExp()、String()、Object()、Array();
* · 全局对象,比如Math 和 JSON

全局对象的初始属性并不是保留字,但它们应该当做保留字来对待，2.4.1节列出了所有的这些属性,本章对一部分全局属性也有描述，其他属性来其他章节也会讲述，可以在第三部分中通过名称查找到,或者听过别名`Clobal`来查找这些全局对象,对于客户端Javascript来讲，window对象定义了一些额外的全局属性，可以在第四部分中查看它们。

在代码的最顶级`不在任何函数内的javascript代码`可以使用javascript关键字this来引用全局对象:

```js
    var global = this;             // 定义一个引用全局对象的全局变量
```
在客户端javascript中，在其表示的浏览器窗口中的所有javascrpt代码中.window独享充当了全局对象，这个全局window对象有一个属性引用其自身，他可以代替this来引用全局对象,window对象定义了核心全局属性，但它也针对了web浏览器和客户端javascript定义了一少部分其它全局属性。

当初次创建的时候，全局对象定义了javascript中所有的预定义全局值，这个特殊对象同样包含了为程序员定义的全局值，如果代码声明了一个全局变量,这个全局变量就是全局对象的一个属性，3.10.2节有关于此的详尽解释。



### 3.6 包装对象

javascript对象是一种复合值:它是属相或已命名值的集合,通过`.`，符号来引用属性值，当属性值是一个函数的时候，称其为方法，通过o.m()来调用对象o中的方法.

我们看到字符串也同样具有属性和方法:

```js
    var s = "hello world!";                                 // 一个字符串
    var word = s.substring(s.indexOf(" ")+1, s.length);     // 使用字符串的属性
```

字符串既然不是对象，为什么他会有属性呢?只要引用了字符串s的属性,javascript就会将字符串通过调用new String(s)的方式转换成对象，这个对象集成了字符串的方法.并被用来处理属性的引用，一旦属性引用结束，这个新创建的对象就会销毁(其实在实现上不一定创建或销毁这个临时对象,然而整个过程看起来是这样.)

同字符串一样，数字和布尔值也具有各自的方法: 通过Number()和Boolean()构造函数创建一个临时对象，这些方法的调用均是来自这个临时对象，null和undefined没有包装对象:访问它们的属性会造成一个类型错误。

看如下代码，思考它们的执行结果:

```js
    var s = 'test';                 // 创建一个字符串
    s.len = 4;                      // 给它设置一个属性
    var t = s.len;                  // 查询这个属性
```

当运行这段代码时,t的值是undefined，第二行代码创建一个临时字符串对象，并给其len属性赋值为4.随即销毁这个对象。第三行通过原始的(没有被修改过)字符串值创建一个新字符串对象，尝试读取其len属性，这个属性自然不存在，表达式求职结果为undefined。这段代码说明了在读取字符串，数字和布尔值的属性值`(或方法)`的时候,表现的想对象一样,但如果你尝试给其属性赋值,则会忽略这个操作: 修改只是发生在临时对象身上,而这个临时对象并未继续保留下来。

存取字符串、数字或布尔值的属性时创建的历史对象称做包装对象，它只是偶尔用来区分字符串值和字符串对象、数字和数值对象以及布尔值和布尔对象.通常，包装对象只是被看做是一种实现细节，而不用特别关注，由于字符串，数字和布尔值的属性都是制度的，并且不能给它们定义新属性，因此你需要明白它们是有别于对象的。

需要注意的是.可通过string()，Number(),或Boolean(),构造函数来显示创建包装对象:

```js
    var s = 'test', n = 1, b = true;    // 一个字符串、数字和布尔值
    var S = new String(s);              // 一个字符串对象
    var N = new Number(n);              // 一个数值对象
    var B = new Boolean(b);             // 一个布尔对象
```

javascript会在必要时将包装对象转换成原始值,因此上段代码中的对象`s`、`n`和`b`一样。'=='等于运算符将原始值和其包装对象视为相等，但 `==`全等运算符将他们视为不等,通过同样typeof运算符可以看到原始值和其包装对象的不同。

### 3.7 不可变的原始值和可变的对象引用

javascript中的原始值(`undefined`、`null`、`布尔值`、`数字`和`字符串`)与对象(包括数组和函数)有着根本区别.原始值是不可更改的:任何地方都无法更改(或`突变`)一个原始值，对数字和布尔值来说显然如此————改变数字的值本身就说不通，而对字符串来说就不那么明显了，因为字符串看起来像字符组成的数组，我们期望可以通过指定索引来修改字符串中的字符，实际上，javascript是禁止这样做的，字符串中所有的方法看上去返回了一个修改后的字符串,实际上返回的是一个新的字符串值，例如:

```js
    var s = 'hello';                    // 定义一个由小写字母组成的文本
    s.toUpperCase();                    // 返回'hello'，但并没有改变s的值
    s                                   // => 'hello' : 原始字符串的值并未改变
```

原始值得比较是值得比较:只有在它们的值相等时它们才相等.这对数字、布尔值、null和undefined来说听起来有点难懂,并没有其他办法来比较它们.同样，对于字符串来说则并不明显：如果比较两个单独的字符串.当且仅当它们的长度相等且每个索引的字符都相等是，javascript才认为它们相等、

对象和原始值不同，首先，它们是可变的————它们的值是可修改的：

```js
    var o = {x : 1};                    // 定义一个对象
    o.x = 2;                            // 通过修改对象属性值来更改对象
    o.y = 3;                            // 再次更改这个对象,给它增加一个新属性

    var a = [1, 2, 3];                  // 数组也是可以修改的
    a[0] = 0;                           // 更改数组的第一个元素
    a[3] = 4;                           // 给数组增加一个新属性
```

对象的比较并非指的比较: 即使两个对象包含同样的属性及相同的值,它们也是不相等的,哥哥索引元素完全相等的两个数组也不相等。

```js
    var o = {x:1}, p = {x:1};           // 具有相同属性的两个对象
    o === p                             // => false : 两个单独的对象永不相等
    var a = [], b = [];                 // 两个单独的空数组
    a === b                             // => false : 两个单独的数组永不相等
```

我们通常将对象称为引用类型 (reference type),以此来和javascript的基本类型区分开来,按照术语的叫法,对象值都是引用(reference),对象的比较均是引用的比较: 当且仅当它们引用同一个基对象时,它们才相等。

```js
    var a = [];                         // 定义一个引用空数组的变量a
    var b = a;                          // 变量b引用同一个数组
    b[0] = 1;                           // 通过变量b来修改引用的数组
    a[0]                                // => 1.变量a也会修改
    a === b                             // => true : a和b引用同一个数组,天赐它们相等
```

就像你刚看到的如上代码,将对象(或数组)赋值给一个变量,仅仅是赋值的引用值: 对象本身并没有复制一次.如果你想得到一个对象或数组的副本,则必须显示复制对象的每个属性或数组的每个元素。下面这个例子则是通过循环来完成数组复制:

```js
    var a = ['a', 'b', 'c'];            // 待复制的数组
    var b = [];                         // 复制道德目标空数组
    for(var i = 0; i < a.length; i++){  // 遍历a[]中的每个元素
       b[i] = a[i];                     // 将元素值复制到b中
    }
```

同样的,如果我们想比较这个单独的对象,或者数组,则必须比较它们的属性或元素.下面这段代码定义了一个比较两个数组的的函数。
```js
    function equalArrays(a, b){
        if(a.length != b.length) return false;    // 两个长度不同的数组不相等
        for(var i = 0; i < a.length; i++)         // 循环遍历所有的元素
            if(a[i] !== b[i]) return false;       // 如果有人以元素不等，则元素不等
        return true;                              // 否则它们相等  
    }
```




![](http://oxoz3bzmd.bkt.clouddn.com/17-10-12/67105377.jpg-picture)